Advanced SQL Interview Questions for Data Analyst

Below are 10 advanced SQL interview questions with sample answers tailored for a Data Analyst role. These questions test complex querying, performance optimization, and database concepts.


---

1. How would you write a SQL query to find duplicate records in a table and remove them while keeping the most recent record based on a timestamp?

Answer: To find duplicates, group by the unique columns and use HAVING to identify duplicates. To keep the most recent record, use a CTE with ROW_NUMBER() to rank records by timestamp and delete all but the top-ranked record.

WITH RankedRecords AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY unique_column ORDER BY timestamp_column DESC) AS rn
    FROM table_name
)
DELETE FROM RankedRecords WHERE rn > 1;


---

2. Explain the difference between a JOIN, UNION, and UNION ALL. When would you use each?

Answer:

JOIN: Combines rows from two or more tables based on a related column (e.g., INNER JOIN, LEFT JOIN). Use it to combine data horizontally.

UNION: Merges result sets vertically, removing duplicates. Use it when combining similar data across tables.

UNION ALL: Same as UNION, but keeps duplicates. Use it when performance is key and duplicates are acceptable.



---

3. Write a SQL query to calculate the running total of sales for each customer over time, ordered by date.

Answer: Use SUM() with OVER partitioned by customer and ordered by date.

SELECT 
    customer_id,
    order_date,
    sale_amount,
    SUM(sale_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS running_total
FROM sales
ORDER BY customer_id, order_date;


---

4. How do you optimize a SQL query that is running slowly on a large dataset?

Answer:

Analyze the execution plan.

Add indexes on filtered/joined columns.

Avoid functions on indexed columns.

Use query hints and rewrite joins.

Partition large tables.

Update statistics.



---

5. Write a SQL query to find the top 3 products by sales in each region for a given year, handling ties appropriately.

Answer: Use DENSE_RANK() to handle ties.

WITH RankedProducts AS (
    SELECT 
        region,
        product,
        SUM(sale_amount) AS total_sales,
        DENSE_RANK() OVER (PARTITION BY region ORDER BY SUM(sale_amount) DESC) AS sales_rank
    FROM sales
    WHERE YEAR(order_date) = 2025
    GROUP BY region, product
)
SELECT region, product, total_sales
FROM RankedProducts
WHERE sales_rank <= 3
ORDER BY region, sales_rank;


---

6. What are Common Table Expressions (CTEs) and when would you use them instead of subqueries?

Answer: CTEs are temporary result sets defined using WITH. They:

Improve readability.

Enable reuse in the query.

Support recursion.


Example:

WITH SalesByRegion AS (
    SELECT region, SUM(sale_amount) AS total_sales
    FROM sales
    GROUP BY region
)
SELECT region, total_sales
FROM SalesByRegion
WHERE total_sales > 100000;


---

7. Write a SQL query to find customers who made purchases in consecutive months.

Answer: Use LAG() to compare current and previous month:

WITH MonthlyPurchases AS (
    SELECT 
        customer_id,
        DATEPART(YEAR, order_date) AS purchase_year,
        DATEPART(MONTH, order_date) AS purchase_month,
        LAG(DATEPART(MONTH, order_date)) OVER (PARTITION BY customer_id ORDER BY order_date) AS prev_month
    FROM sales
)
SELECT DISTINCT customer_id
FROM MonthlyPurchases
WHERE purchase_month = prev_month + 1
   OR (purchase_month = 1 AND prev_month = 12 AND purchase_year = 
       LAG(purchase_year) OVER (PARTITION BY customer_id ORDER BY purchase_year, purchase_month) + 1);


---

8. How do you handle NULL values in SQL aggregations, and what are the implications?

Answer:

Aggregates like SUM, AVG ignore NULLs.

Use COALESCE or ISNULL to replace NULLs.

Use NULLIF to avoid invalid values.

Be careful with joinsâ€”NULLs can exclude rows unless using LEFT JOIN.


Implication: NULLs may skew results if not handled properly.


---

9. Write a SQL query to pivot sales data by product category across quarters in a given year.

Answer: Using PIVOT:

SELECT *
FROM (
    SELECT 
        product_category,
        DATEPART(QUARTER, order_date) AS quarter,
        sale_amount
    FROM sales
    WHERE YEAR(order_date) = 2025
) AS SourceTable
PIVOT (
    SUM(sale_amount)
    FOR quarter IN ([1], [2], [3], [4])
) AS PivotTable;

Using conditional aggregation:

SELECT 
    product_category,
    SUM(CASE WHEN DATEPART(QUARTER, order_date) = 1 THEN sale_amount ELSE 0 END) AS Q1,
    SUM(CASE WHEN DATEPART(QUARTER, order_date) = 2 THEN sale_amount ELSE 0 END) AS Q2,
    SUM(CASE WHEN DATEPART(QUARTER, order_date) = 3 THEN sale_amount ELSE 0 END) AS Q3,
    SUM(CASE WHEN DATEPART(QUARTER, order_date)

